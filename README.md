# problem-5-1

## 가상머신과 컨테이너의 차이

### 가상머신 (Virtual Machine)

**정의**: 물리적 하드웨어를 가상화하여 독립적인 운영체제를 실행하는 기술

**특징**:

- 하이퍼바이저를 통한 하드웨어 수준 가상화
- 각 VM은 완전한 운영체제를 포함
- 강력한 격리 수준 제공

**장점**:

- 완전한 격리 환경
- 서로 다른 운영체제 실행 가능
- 보안성이 높음

**단점**:

- 높은 리소스 사용량
- 느린 시작 시간 (분 단위)
- 큰 저장 공간 필요 (GB 단위)


### 컨테이너 (Container)

**정의**: 운영체제 수준에서 애플리케이션을 격리하여 실행하는 경량 가상화 기술

**특징**:

- 호스트 OS 커널을 공유
- 애플리케이션과 의존성만 패키징
- 프로세스 수준 격리

**장점**:

- 낮은 리소스 사용량
- 빠른 시작 시간 (초 단위)
- 작은 저장 공간 (MB 단위)
- 높은 포터빌리티

**단점**:

- VM보다 상대적으로 약한 격리
- 같은 OS 커널을 공유해야 함


### 비교 표

| 항목 | 가상머신 | 컨테이너 |
| :-- | :-- | :-- |
| **격리 방식** | 하드웨어 수준 | 프로세스 수준 |
| **리소스 사용** | 높음 | 낮음 |
| **시작 시간** | 분 단위 | 초 단위 |
| **크기** | GB 단위 | MB 단위 |
| **성능** | 오버헤드 존재 | 네이티브 성능 |
| **OS 다양성** | 다양한 OS 지원 | 같은 OS 커널 |

## 컨테이너와 이미지의 차이

### 컨테이너 (Container)

**정의**: 이미지의 실행 가능한 인스턴스

**특징**:

- 런타임 환경
- 실행 중인 프로세스
- 메모리, CPU, 네트워크 리소스 사용
- 생성, 시작, 중지, 삭제 가능

**상태**:

- Running (실행 중)
- Stopped (중지됨)
- Paused (일시 정지)


### 이미지 (Image)

**정의**: 컨테이너를 생성하기 위한 읽기 전용 템플릿

**특징**:

- 정적 파일 시스템
- 애플리케이션 코드와 의존성 포함
- 불변(Immutable) 특성
- 레이어 구조로 구성

**구성 요소**:

- 애플리케이션 바이너리
- 라이브러리 및 의존성
- 환경 변수
- 메타데이터


### 관계도

```
이미지 (Template) → 컨테이너 (Runtime Instance)
      ↓                    ↓
  정적 파일             실행 중인 프로세스
  읽기 전용             읽기/쓰기 가능
  불변성               상태 변경 가능
```


## 컨테이너 런타임 정의

### 컨테이너 런타임 (Container Runtime)

**정의**: 컨테이너의 전체 생명주기를 관리하는 소프트웨어 시스템

### 주요 기능

1. **컨테이너 생명주기 관리**
    - 컨테이너 생성 (Create)
    - 컨테이너 시작 (Start)
    - 컨테이너 중지 (Stop)
    - 컨테이너 삭제 (Delete)
2. **리소스 관리**
    - CPU, 메모리 할당
    - 네트워크 구성
    - 스토리지 마운트
    - 보안 정책 적용
3. **격리 기능**
    - 네임스페이스 관리
    - cgroups 제어
    - 보안 컨텍스트 설정

### 런타임 계층

**High-level Runtime**: 사용자 친화적 인터페이스 제공
**Low-level Runtime**: 실제 컨테이너 실행 담당

## CNCF Landscape 기반 컨테이너 런타임 3가지

### 1. containerd

**개발사**: CNCF (Cloud Native Computing Foundation)
**특징**:

- 고성능, 안정성 중심 설계
- Kubernetes 기본 런타임
- 산업 표준 CRI(Container Runtime Interface) 지원
- Docker에서 분리된 독립적인 런타임

**사용 사례**:

- Kubernetes 클러스터
- 클라우드 네이티브 환경
- 프로덕션 환경


### 2. CRI-O

**개발사**: Red Hat
**특징**:

- Kubernetes 전용 설계
- OCI(Open Container Initiative) 표준 완전 준수
- 경량화된 아키텍처
- 보안 중심 설계

**사용 사례**:

- OpenShift 플랫폼
- 엔터프라이즈 Kubernetes
- 보안이 중요한 환경


### 3. Docker Engine

**개발사**: Docker Inc.
**특징**:

- 가장 널리 사용되는 런타임
- 개발자 친화적 CLI
- Docker Hub 연동
- 풍부한 생태계

**사용 사례**:

- 개발 환경
- 로컬 테스트
- CI/CD 파이프라인


## 도커 이미지의 레이어

### 레이어 (Layer) 개념

**정의**: 도커 이미지를 구성하는 읽기 전용 파일 시스템의 개별 계층

### 레이어 구조

```
┌─────────────────────┐
│   Application Layer │  ← 애플리케이션 코드
├─────────────────────┤
│   Library Layer     │  ← 라이브러리 및 의존성
├─────────────────────┤
│   Runtime Layer     │  ← 런타임 환경
├─────────────────────┤
│   OS Layer          │  ← 기본 운영체제
└─────────────────────┘
```


### 레이어 특징

1. **불변성 (Immutability)**
    - 한 번 생성된 레이어는 변경 불가
    - 새로운 변경사항은 새 레이어로 생성
2. **재사용성 (Reusability)**
    - 동일한 레이어를 여러 이미지가 공유
    - 저장 공간 효율성 향상
3. **캐싱 (Caching)**
    - 빌드 시 기존 레이어 재사용
    - 빌드 시간 단축

### Union File System

**동작 원리**:

- 여러 레이어를 하나의 파일 시스템으로 통합
- 상위 레이어가 하위 레이어를 덮어씀
- 컨테이너 실행 시 쓰기 가능한 레이어 추가


### 레이어 최적화 방법

1. **Multi-stage Build 사용**

```dockerfile
FROM node:16 AS builder
COPY package*.json ./
RUN npm install

FROM node:16-alpine
COPY --from=builder /app /app
```

2. **명령어 결합**

```dockerfile
# 비효율적
RUN apt-get update
RUN apt-get install -y curl

# 효율적
RUN apt-get update && apt-get install -y curl
```

3. **.dockerignore 파일 사용**
    - 불필요한 파일 제외
    - 레이어 크기 최소화

### 레이어 확인 명령어

```bash
# 이미지 히스토리 확인
docker history [IMAGE_NAME]

# 이미지 상세 정보 확인
docker inspect [IMAGE_NAME]
```